<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NixOS Benchmark Runs</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; color: #1f2429; background: #fdfdfd; }
    h1 { margin: 0 0 0.5rem; }
    .filters { margin: 1rem 0; padding: 1rem; background: #f8f9fa; border: 1px solid #e3e3e3; border-radius: 4px; }
    .filters h2 { margin: 0 0 0.75rem; font-size: 1rem; }
    .filter-checkboxes { display: flex; flex-wrap: wrap; gap: 1rem; }
    .filter-checkbox { display: inline-flex; align-items: center; gap: 0.3rem; cursor: pointer; }
    .filter-checkbox input { cursor: pointer; }
    table { border-collapse: collapse; width: 100%; background: #fff; border: 1px solid #d9d9d9; margin-top: 1rem; }
    th, td { border: 1px solid #e3e3e3; padding: 0.45rem 0.6rem; text-align: left; vertical-align: top; }
    th { background: #f4f6f8; font-weight: 700; }
    tr:nth-child(even) { background: #fbfbfc; }

    /* Category headers */
    .category-header { background: #e8eef5; text-align: center; font-weight: 700; border-bottom: 2px solid #a0aec0; }
    .benchmark-header { font-size: 0.85rem; }

    .run-file a { color: #0b73e0; text-decoration: none; }
    .run-file a:hover { text-decoration: underline; }
    .run-generated { white-space: nowrap; color: #3c4650; }
    .run-system { min-width: 16rem; }
    .system-label { font-weight: 700; }
    .system-meta { color: #5a646f; font-size: 0.9rem; margin-top: 0.1rem; line-height: 1.25; cursor: help; }
    .run-presets .preset-label { color: #1f2429; font-size: 0.95rem; }
    .cell-main { font-weight: 600; }
    .cell-version { color: #5a646f; font-size: 0.8rem; margin-top: 0.2rem; }

    /* Hidden cells/columns */
    .hidden { display: none; }

    /* Sortable headers */
    th.sortable {
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    th.sortable::after {
      content: "";
      position: absolute;
      right: 0.4rem;
      font-size: 0.7rem;
      opacity: 0.4;
    }

    th.sortable[data-order="asc"]::after {
      content: "▲";
    }

    th.sortable[data-order="desc"]::after {
      content: "▼";
    }
  </style>
</head>
<body>
  <h1>Benchmark Runs</h1>
  <div class="filters">
    <h2>Filter Benchmarks by Category</h2>
    <div class="filter-checkboxes">
      ${filter_checkboxes}
    </div>
  </div>
  <table id="benchmark-table">
    <thead>
      <tr class="category-row">
        <th rowspan="2" class="sortable" data-type="text">System</th>
        <th rowspan="2" class="sortable" data-type="text">Presets</th>
        <th rowspan="2" class="sortable run-generated-header" data-type="date">Run Date</th>
        ${category_header_cells}
        <th rowspan="2" class="sortable" data-type="text">Report</th>
      </tr>
      <tr class="benchmark-row">
        ${benchmark_header_cells}
      </tr>
    </thead>
    <tbody>
      ${table_html}
    </tbody>
  </table>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const table = document.getElementById('benchmark-table');
      const tbody = table.querySelector('tbody');
      const filterCheckboxes = document.querySelectorAll('.filter-checkbox input');

      // Collect all sortable headers from both header rows and map them to their actual column indices
      const categoryRow = table.querySelector('thead tr.category-row');
      const benchmarkRow = table.querySelector('thead tr.benchmark-row');

      // Build a map of header elements to their actual column indices
      const headerToColumnIndex = new Map();
      const allSortableHeaders = [];

      // Process category row (System, Presets, Run Date, Report with rowspan=2)
      let colIndex = 0;
      Array.from(categoryRow.children).forEach(th => {
        const colspan = parseInt(th.getAttribute('colspan') || '1', 10);
        const rowspan = parseInt(th.getAttribute('rowspan') || '1', 10);

        if (th.classList.contains('sortable')) {
          headerToColumnIndex.set(th, colIndex);
          allSortableHeaders.push(th);
        }

        if (rowspan === 2) {
          // This header spans both rows, so it occupies one column
          colIndex++;
        } else {
          // This header has benchmark headers below it, skip those columns
          colIndex += colspan;
        }
      });

      // Process benchmark row headers
      colIndex = 3; // Start after System, Presets, Run Date
      Array.from(benchmarkRow.children).forEach(th => {
        if (th.classList.contains('sortable')) {
          headerToColumnIndex.set(th, colIndex);
          allSortableHeaders.push(th);
        }
        colIndex++;
      });

      function getCellValue(row, index) {
        const cell = row.children[index];
        const sortValue = cell.getAttribute('data-sort');
        return (sortValue || cell.textContent).trim();
      }

      function parseValue(value, type) {
        if (type === 'date') {
          const t = Date.parse(value);
          return isNaN(t) ? 0 : t;
        }

        if (type === 'number') {
          const m = value.match(/-?\\d+(\\.\\d+)?/);
          if (m) return parseFloat(m[0]);
        }

        // default: text
        return value.toLowerCase();
      }

      function sortByColumn(index, type, order) {
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.sort((a, b) => {
          const va = parseValue(getCellValue(a, index), type);
          const vb = parseValue(getCellValue(b, index), type);

          if (va < vb) return order === 'asc' ? -1 : 1;
          if (va > vb) return order === 'asc' ? 1 : -1;
          return 0;
        });

        rows.forEach(row => tbody.appendChild(row));
      }

      // Add click handlers to all sortable headers
      allSortableHeaders.forEach(header => {
        header.addEventListener('click', () => {
          const currentOrder = header.getAttribute('data-order') === 'asc' ? 'asc' : 'desc';
          const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
          const type = header.getAttribute('data-type') || 'text';
          const columnIndex = headerToColumnIndex.get(header);

          // reset other headers
          allSortableHeaders.forEach(h => {
            if (h !== header) h.removeAttribute('data-order');
          });

          header.setAttribute('data-order', newOrder);
          sortByColumn(columnIndex, type, newOrder);
        });
      });

      // Filter functionality
      filterCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          const activeCategories = new Set();
          filterCheckboxes.forEach(cb => {
            if (cb.checked) activeCategories.add(cb.value);
          });

          // Show/hide category headers
          Array.from(categoryRow.children).forEach(header => {
            const category = header.getAttribute('data-category');
            if (category) {
              if (activeCategories.has(category)) {
                header.classList.remove('hidden');
              } else {
                header.classList.add('hidden');
              }
            }
          });

          // Show/hide benchmark headers
          Array.from(benchmarkRow.children).forEach(header => {
            const category = header.getAttribute('data-category');
            if (category) {
              if (activeCategories.has(category)) {
                header.classList.remove('hidden');
              } else {
                header.classList.add('hidden');
              }
            }
          });

          // Show/hide cells in body rows
          const rows = tbody.querySelectorAll('tr');
          rows.forEach(row => {
            const cells = row.querySelectorAll('td.benchmark-cell');
            cells.forEach(cell => {
              const category = cell.getAttribute('data-category');
              if (category) {
                if (activeCategories.has(category)) {
                  cell.classList.remove('hidden');
                } else {
                  cell.classList.add('hidden');
                }
              }
            });
          });
        });
      });

      // Default sort: by Run Date column, newest first
      const runDateHeader = allSortableHeaders.find(h => h.classList.contains('run-generated-header'));
      if (runDateHeader) {
        const runDateIndex = headerToColumnIndex.get(runDateHeader);
        runDateHeader.setAttribute('data-order', 'desc');
        sortByColumn(runDateIndex, 'date', 'desc');
      }
    });
  </script>
</body>
</html>
